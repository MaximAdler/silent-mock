import re

from asyncpg.exceptions import ForeignKeyViolationError

import db # instance of Gino or SQLAlchemy

from sqlalchemy.engine.url import URL


class ModelsConstructor:
    param = None
    
    def __init__(self, *models, cleanup: bool = True) -> None:
        self._models = {}
        for Model in [model(param=ModelsConstructor.param) for model in models]:
            table_name = f'{Model.__tablename__}'
            if table_name in self._models:
                if not isinstance(self._models[table_name], list):
                    self._models[table_name] = [self._models[table_name]]
                self._models[table_name].append(Model)
            else:
                self._models[table_name] = Model
        
        self.cleanup = cleanup

    async def __aenter__(self) -> dict:
        async with db.transaction():
            for models in self._models.values():
                if not isinstance(models, list):
                    models = [models]
                for model in models:
                    await model.create()
        return self._models

    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        if not self.cleanup:
            return None
 
        stack = list(self._models.values())
        for model in stack:
            if isinstance(model, list):
                stack += model
                continue
            try:
                table = model.__class__
                await table.delete.where(table.id == model.id).gino.status()
                if 'name' in list(table._column_name_map):
                    await table.delete.where(table.name.like('Test %')).gino.status()
            except ForeignKeyViolationError:
                stack.append(model)

    @property
    def models(self):
        return self._models


class TestingModelMeta(type):
    """
    Metaclass for having possibility to write mocks by classes.
    For example:
        class A(metaclass=TestingModelMMeta):
            _model = SomeTable
            _autogenerated = ['id']

            example_col = 5

    That means that class A will use SomeTable as mmodel for creating mocked record.
    _autogenerated class variable store column names and parametrized data will be included in them.
    All other class variables store column names which data will set statically.
    """
    __tablename__ = None
    _model = None
    _autogenerated = []
    _static_fields = {}

    def __call__(cls, *args, **kwargs):
        """
        Create record by SQLAlchemy Model.
        Class will have possibility to use __tablename__ that we have in Model.
        We collect static fields (columns that don't need parametrized data).
        We assume all class variables that haven't '_' at the start of name will be static.
        """
        if kwargs.get('param') is None:
            raise BaseException('The `param` must be passed during initialization.')

        cls.__tablename__ = cls._model.__tablename__
        cls._static_fields = {key: value for key, value in cls.__dict__.items() if not bool(re.match(r'_\w+), key)}
        
        autogenerated_fields = {field_name: kwargs['param'] for field_name in cls._autogenerated}
        return cls._model(**autogenerated_fields, **cls._static_fields)

    def __new__(cls, name, bases, dct, *args, **kwargs):
        """
        Check if new class have class variable _model and
        if _model is instance of SQLAlchemy Model.
        """
        if dct.get('_model') is None:
            raise BaseException('Class variable `_model` must be assigned')

        if not hasattr(dct['_model'], '__dict__') or \
                '__tablename__' not in dct['_model'].__dict__:
            raise BaseException('Class variable `_model` must be child of db.Model.')

        return super(TestingModelMeta, cls).__new__(cls, name, bases, dct)


class TestingModel:
    def __init__(self, param):
        self.param = param

